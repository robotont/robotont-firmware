# Firmware architecture

This document contains all the necessary information to begin developing the Robotont firmware. It is divided into specific sections as follows:
<!-- https://github.com/derlin/bitdowntoc -->
- [Firmware architecture](#firmware-architecture)
   * [General overview](#general-overview)
   * [Application layer](#application-layer)
   * [Service layer](#service-layer)
   * [BSP layer](#bsp-layer)
   * [Interface layer](#interface-layer)
   * [MCU HAL and core](#mcu-hal-and-core)
   * [Limitations](#limitations)
   * [Branching strategy (working with git)](#branching-strategy-working-with-git)

## General overview

In this project, the author used a layered architecture approach. The firmware is divided into separate abstraction layers. The higher the layer's position, the less it depends on project-specific hardware.

Firmware design diagram and legend accordingly:
<p float="left">
  <img align="top" src=".images/fw_architecture.png" width="600" />
  <img align="top" src=".images/fw_architecture_legend.png" width="200" /> 
</p>

Robotont firmware divided into the five layers:
|Layer|Brief description|
|---|---|
|Application layer|The highest level of abstraction. It defines how various services within Robotont should interact.|
|Service layer|Describes the tasks (or services) a robot should independently perform. Each service must include its own `update` function (non-blocking).|
|BSP layer|Board Support Package layer, also referred to as the Hardware Driver layer. Contains firmware drivers for specific hardware.|
|Interface layer| Wrapper over `STM32F4 HAL` functions. Provides simplified interface to communicate with MCU peripherals. Contains only used peripherals.|
|MCU HAL and core|MCU-specific components that were auto-generated by the `STM32CubeMX` program.|

> [!IMPORTANT]  
> The bottom-level module should never include modules from the top level. This approach will keep the code more portable, not only in terms of MCU and hardware but also in terms of application.

In repository, file tree looks like this:
```
lib/         - External libraries
src/         - Robotont project files
├─ app/          - Application layer files
├─ hw/           - BSP layer files
├─ mcu/          - Interface layer files
├─ stm-core/     - MCU HAL and core files, mostly generated
├─ svc/          - Service layer files
│  ├─ cfg/           - Service related config
```

## Application layer

<img align="top" src=".images/fw_arch_app.png" width="800" />

</br>
Purpose of application layer is to define, how all services acts together as a whole. Currently, Robotont have only one application component: main file. 

For example, if developer wants to implement such logic, as "If battery monitor detects overvoltage, then robot should not move", this is the right place to do so.

C-based pseudo code:
```cpp

void main(void)
{
    while (true)
    {
        BatteryStatusType bat_status = battery_getStatus();
        if (bat_status == BATTERY_OVERVOLTAGE)
        {
            movement_stop();
        }
        else
        {
            movement_start();
        }

        battery_update();
        movement_update();
    }
}
```

## Service layer

<img align="top" src=".images/fw_arch_svc.png" width="800" />

</br>
Purpose of service layer is to define which tasks Robotont should perform. Each task (or service) is individual component and should be independent. Communications with services should be mostly performed via getters and setters in the application layer.

Robotont have five services:
|Service|Description|
|---|---|
|CMD handler|Redirects serial data-in to the according service. See [serial communication](./../README.md#serial-communication) for supported arguments. Also, `printf` function redirected here to serve as serial output.|
|Movement control|Calculates each motor speed based on Robotont's desired direction and speed (omnimotional movement).</br>Calculates Robotont's odometry based on robot's movement.|
|LED control|Defines addressable LED behavior.|
|OLED control|Defines OLED screen behavior, such as what information to show on the screen.|
|Battery monitor|Communicates with Battery monitor HW to check 12V battery status.|

</br>
Using this architecture, removing, adding and changing tasks is significantly easier, since dependencies are hidden within one component. 

## BSP layer

## Interface layer

## MCU HAL and core

## Limitations



